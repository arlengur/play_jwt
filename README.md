JSON Web Token (JWT) 
---
Для обеспечения безопасности пользователя сервис использует [JWT](https://jwt.io/)

JWT содержит три блока, разделенных точками: заголовок(header), набор полей (payload) и сигнатуру. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие). Сигнатура может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

Токены предоставляют собой средство авторизации для каждого запроса от клиента к серверу. Токены (и соотвественно сигнатура токена) генерируются на сервере основываясь на секретном ключе (который хранится на сервере). Токен в итоге хранится на клиенте и используется при необходимости авторизации какого-либо запроса.

При попытке хакером подменить данные в header'ре или payload'е, токен станет не валидным, поскольку сигнатура не будет соответствовать изначальным значениям. А возможность сгенерировать новую сигнатуру у хакера отсутствует, поскольку секретный ключ для зашифровки лежит на сервере.
* access token - используется для авторизации запросов и хранения дополнительной информации о пользователе (аля user_id, user_role или еще что либо, эту информацию также называет payload)
* refresh token - выдается сервером по результам успешной аутентификации и используется для получения нового access token'a и обновления refresh token'a

Каждый токен имеет свой срок жизни, например access: 30мин, refresh: 60дней.

Поскольку токены это не зашифрованная информация крайне не рекомендуется хранить в них такую информацию как пароли. 

####Роль рефреш токенов и зачем их хранить в БД.
Рефреш на сервере \*хранится\* для учета доступа и инвалидации краденых токенов. Таким образом сервер наверняка знает о клиентах которым стоит доверять(кому позволено авторизоваться). Если не хранить рефреш токен в БД то велика вероятность того что токены будут бесконтрольно гулять по рукам злоумышленников. Для отслеживания которых нам прийдется заводить черный список и периодически чистить его от просроченных. В место этого мы храним лимитированный список белых токенов для каждого юзера отдельно и в случае кражи у нас уже есть механизм противодействия.

####Схема создания/использования токенов (/login)
1. Пользователь логинится в приложении, передавая логин/пароль на сервер.
2. Сервер проверят подлинность логина/пароля, в случае удачи генерирует и отправляет клиенту два токена (access, refresh) и время смерти access token'а (expires_in поле, в unix timestamp). Также в payload refresh token'a добавляется user_id.
    * **accessToken**: "...",
    * **refreshToken**: "...",
    * **expires_in**: 1502305985425
3. Клиент сохраняет токены и время смерти access token'а, используя access token для последующей авторизации запросов.
```
Authorization: Bearer <token>
```
4. Перед каждым запросом клиент предварительно проверяет время жизни access token'а (из expires_in) и если оно истекло использует refresh token чтобы обновить оба токена и продолжает использовать новый access token.

#### Схема рефреша токенов (/refresh-token):
1. Клиент проверяет перед запросом не истекло ли время жизни access token'на.
2. Если истекло клиент отправляет на /refresh-token URL refresh token.
```
Refresh-Token: Bearer <token>
```
3. Сервер берет *user_id* из payload'a refresh token'a по нему ищет в БД запись данного юзера и достает из него refresh token.
4. Сравнивает refresh token клиента с refresh token'ом найденным в БД.
5. Проверяет валидность и срок действия refresh token'а.
6. В случае успеха сервер:
    * Создает и перезаписывает refresh token в БД
    * Создает новый access token
    * Отправляет оба токена и новый expires_in access token'а клиенту
7. Клиент повторяет запрос к API c новым access token'ом.

С такой схемой юзер сможет быть залогинен только на одном устройстве. Тоесть в любом случае при смене устройства ему придется логинится заново.

#### Device-id мобильного клиента. 
В нашей системе мы дополнительно используем _device-id_ мобильного клиента. Когда пользователь подключается к сервису посредством мобильных устройств, то он передает свой device-id в хедере. ИД сохраняется в сервисе и ассоциирует с ним пользователя. Таким образом пользователь может пользоваться сервисом без необходимости явной аунтефикации. Но если пользователь захочет получить платную подписку, то ему будет необходимо явно зарегистрироваться в системе.

#### TDD

/:
- Если в заголовке запроса не передан device-id, то возвращается
401 Unauthorized: Device-id has not been sent.
- Если в заголовке запроса передан device-id, то возвращается
200 OK: Home link with free access.

/login:
- Если в заголовке запроса не передан device-id, то возвращается
401 Unauthorized: Device-id has not been sent.
- Если пользователь с таким именем и паролем не найден, то возвращается
404 Not Found: User with such name or password not found.
- Если пользователь найден, то возвращается
200 OK: пользователю выдаются 2 ключа (Access-Token и Refresh-Token) и время жизни Access-Token (Expires-In)
- Если передан невалидный JSON, то возвращается
400 BAD_REQUEST: Ошибка валидации

/register:
- Если в заголовке запроса не передан device-id, то возвращается
401 Unauthorized: Device-id has not been sent.
- Если пользователь с таким именем уже существует, то возвращается
409 Conflict: User with such name already exists.
- Если пользователь не найден, то возвращается
200 OK: пользователю выдаются 2 ключа (Access-Token и Refresh-Token) и время жизни Access-Token (Expires-In)

/media:
- Если в заголовке запроса не передан device-id, то возвращается
401 Unauthorized: Device-id has not been sent.
- Если в заголовке запроса Authorization не передан token, то возвращается
401 Unauthorized
- Если token валидный, то возвращается
200 OK
- Если token невалидный, то возвращается
401 Unauthorized: Ошибка валидации